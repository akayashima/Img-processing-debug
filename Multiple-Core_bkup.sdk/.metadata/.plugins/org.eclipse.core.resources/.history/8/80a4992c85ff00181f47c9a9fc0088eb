#include <stdio.h>
#include <stdlib.h>
#include <xil_printf.h>
#include <xtmrctr.h>
#include <xmutex.h>
#include <xmutex_g.c>
#include <xmutex_hw.h>

XTmrCtr TimerCounterInst;

void Show_Time(u32, u32);
void Mailbox_WB(XMbox *,u32 *,u32);//Write Blocking
void Mailbox_RB(XMbox *,u32 *,u32);//Read Blocking
void Mailbox_SetInterruptEnable(XMbox *, u32);
u32 Mailbox_GetInterruptEnable(XMbox *);
u32 Mailbox_GetInterruptStatus(XMbox *);
void Mailbox_ClearInterrupt(XMbox *, u32);

u32 Mailbox_FlagRegister();

int init();

int main()
{
	u32 tStart,tEnd,Mask,Value;
	u32 BufferTx[20];
	u32 BufferRx[20];
	u32 RequestedBytes=20,BytesRecvdPtr=888,BytesSentPtr=999;
	//XMbox ConfigPtr;
	XMbox mbox[2];
	XMbox_Config *InsPtr[2];
	int i=1,Status;
	u32 mbox_status;

	xil_printf("\r\n MB 0 Start");
	//init();

    //-- Mailbox 0
	InsPtr[0] = XMbox_LookupConfig(XPAR_MBOX_0_DEVICE_ID);
	Status = XMbox_CfgInitialize(&mbox[0], InsPtr[0], XPAR_MBOX_0_BASEADDR);//mailbox0 initialize
	if(Status != XST_SUCCESS){
		xil_printf("\r\n Mailbox Initialize Error ");
	}

	XMbox_SetSendThreshold(&mbox[0], 32);//送信FIFOの閾値設定
	XMbox_SetReceiveThreshold(&mbox[0], 32);//受信FIFOの閾値設定

	XMbox_ResetFifos(&mbox[0]);//FIFOのリセット

	mbox_status = XMbox_GetStatus(&mbox[0]);

	/*レジスタを調べる*/
	return XMB_IX_STA;
	return XMB_IX_RTA;
	return XMB_IX_ERR;


	mbox_status = Mailbox_GetInterruptEnable(&mbox[0]);
	mbox_status = Mailbox_GetInterruptStatus(&mbox[0]);
	Mailbox_ClearInterrupt(&mbox[0], XMB_IX_RTA);






	for (i=0; i<20; i++) {
		BufferTx[i] = i;
		BufferRx[i] = 999;
	}

	Mailbox_WB(&mbox[0],&BufferTx[0], 80);

	for(;;){

	}



   mbox_status = XMbox_GetStatus(&mbox[0]);



	/*Status = XMbox_Read(&mbox[1],&BufferRx[0], 80, &BytesRecvdPtr);
		if(Status != XST_SUCCESS){
			xil_printf("\r\n Mailbox Write Error /r/n");
		}*/


	/*Status = XMbox_Read(&InsPtr,&BufferPtr,&RequestedBytes,&BytesRecvdPtr);//mailbox read
	if(Status != XST_SUCCESS){//XST_NO_DATA or XST_SUCCESS
		xil_printf("\r\n Mailbox Read Error /r/n");
	}*/

	//XMbox_ReadBlocking(&InsPtr,&BufferPtr,&RequestedBytes);

	//XMbox_WriteBlocking(&InsPtr,&BufferPtr,&RequestedBytes);
	//XMbox_IsEmpty(&InsPtr);
	//XMbox_IsFull(&InsPtr);
	/*Status = XMbox_Flush(&InsPtr);
	if(Status != XST_SUCCESS){
		xil_printf("\r\n Mailbox Flush Error /r/n");
	}*/
	//XMbox_ResetFifos(&InsPtr);
	//XMbox_SetInterruptEnable(&InsPtr,&Mask);
	//XMbox_GetInterruptEnable(&InsPtr);
	//XMbox_GetInterruptStatus(&InsPtr);
	//XMbox_ClearInterrupt(&InsPtr,&Mask);
	//XMbox_SetSendThreshold(&InsPtr,&Value);
	//XMbox_SetReceiveThreshold(&InsPtr,&Value);
	//XMbox_GetStatus(&InsPtr);
	//XMbox_SetSendThreshold(&InsPtr, &Value);

	//tStart = XTmrCtr_GetValue(&TimerCounterInst, 0);

	//tEnd = XTmrCtr_GetValue(&TimerCounterInst, 0);
	//Show_Time(tEnd, tStart);

}

int init()
{
	int Status;

	Status = XTmrCtr_Initialize(&TimerCounterInst, XPAR_AXI_TIMER_0_DEVICE_ID);
	if (Status != XST_SUCCESS) {
		xil_printf("\r\n Timer Initialize Error \r\n");
		return XST_FAILURE;
	}
	XTmrCtr_SetOptions(&TimerCounterInst, 0, XTC_AUTO_RELOAD_OPTION);
	XTmrCtr_Start(&TimerCounterInst, 0);
	return 0;
}

void Show_Time(u32 tEnd, u32 tStart)
{
	double tt = 0.0;
	int m,b;
	//float tt=0.0;

	tt = (1.0 * (double) (tEnd - tStart) / 100000000.0);
	//tt = (1.0 * (float)(tEnd - tStart) / 100000000.0);

	m = tt;//小数点以下を切り捨ててsecとする
	b = (tt - m) * 1000000000;//nsecまで表示

	xil_printf("\r\n(MicroBlaze)\r\n");
	xil_printf("\r\n Time=%4d.%09d[s]\r\n", m, b);

}

void Mailbox_RB(XMbox *InstancePtr, u32 *BufferPtr,
			u32 RequestedBytes)
{
	u32 NumBytes;

	u32 InterruptStatus;

	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(!((u32) BufferPtr & 0x3));
	Xil_AssertVoid(RequestedBytes != 0);
	Xil_AssertVoid((RequestedBytes % 4) == 0);

	NumBytes = 0;

	if (InstancePtr->Config.UseFSL == 0) {
		/* For memory mapped IO */
		/* Block while the mailbox FIFO has at-least some data */

		do {
			while(XMbox_IsEmptyHw(InstancePtr->Config.BaseAddress));

			/*
			 * Read the Mailbox until empty or the length
			 * requested is satisfied
			 */
			*BufferPtr++ =
				XMbox_ReadMBox(InstancePtr->Config.BaseAddress);

			/*original*/

			InterruptStatus = XMbox_GetInterruptStatus(InstancePtr);

			xil_printf("\r\n Read Value = %d ",(*BufferPtr) * 10);

			NumBytes += 4;
		} while (NumBytes != RequestedBytes);
	} else {

		/* FSL based Access */
		/* Block while the mailbox FIFO has at-least some data */

		do {
			while (XMbox_FSLIsEmpty(InstancePtr->Config.RecvID));

			/*
			 * Read the Mailbox until empty or the length requested
			 * is satisfied
			 */

			*BufferPtr++ =
				XMbox_FSLReadMBox(InstancePtr->Config.RecvID);
			NumBytes += 4;
		} while (NumBytes != RequestedBytes);
	}
}

void Mailbox_WB(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)
{
	u32 NumBytes;
	u32 InterruptStatus;

	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(!((u32) BufferPtr & 0x3));
	Xil_AssertVoid(RequestedBytes != 0);
	Xil_AssertVoid((RequestedBytes %4) == 0);

	NumBytes = 0;

	if (InstancePtr->Config.UseFSL == 0) {
		/* For memory mapped IO */
		/* Block while the mailbox FIFO becomes free to transfer
		 * at-least one word
		 */
		do {
			while (XMbox_IsFullHw(InstancePtr->Config.BaseAddress));

			XMbox_WriteMBox(InstancePtr->Config.BaseAddress,
					 *BufferPtr++);

			/*original*/

			InterruptStatus = XMbox_GetInterruptStatus(InstancePtr);

			xil_printf("\r\n Write Value = %d ", *BufferPtr);

			NumBytes += 4;
		} while (NumBytes != RequestedBytes);
	} else {

		/* FSL based Access */
		/* Block while the mailbox FIFO becomes free to transfer
		 * at-least one word
		 */
		do {
			while (XMbox_FSLIsFull(InstancePtr->Config.SendID));

			XMbox_FSLWriteMBox(InstancePtr->Config.SendID,
					    *BufferPtr++);
			NumBytes += 4;
		} while (NumBytes != RequestedBytes);
	}
}

void Mailbox_SetInterruptEnable(XMbox *InstancePtr, u32 Mask)
{
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(InstancePtr->Config.UseFSL == 0);

	if (InstancePtr->Config.UseFSL == 0)
		XMbox_WriteReg(InstancePtr->Config.BaseAddress,
			       XMB_IE_REG_OFFSET,
			       Mask);
}

u32 Mailbox_GetInterruptEnable(XMbox *InstancePtr)
{
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(InstancePtr->Config.UseFSL == 0);

	return XMbox_ReadReg(InstancePtr->Config.BaseAddress,
				XMB_IE_REG_OFFSET);
}

u32 Mailbox_GetInterruptStatus(XMbox *InstancePtr)
{
	Xil_AssertNonvoid(InstancePtr != NULL);
	Xil_AssertNonvoid(InstancePtr->Config.UseFSL == 0);

	return XMbox_ReadReg(InstancePtr->Config.BaseAddress,
				XMB_IS_REG_OFFSET);
}


void Mailbox_ClearInterrupt(XMbox *InstancePtr, u32 Mask)
{
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(InstancePtr->Config.UseFSL == 0);

	if (InstancePtr->Config.UseFSL == 0) {
		XMbox_WriteReg(InstancePtr->Config.BaseAddress,
				XMB_IS_REG_OFFSET,
				Mask);
	}
}
